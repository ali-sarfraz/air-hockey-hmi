<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Care-Hockey Table HMI: MessageHandler Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Care-Hockey Table HMI
   </div>
   <div id="projectbrief">Used to create a user interface or HMI for that game of air-hockey that also records game data and simulates communication with an embedded system</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="#pri-static-attribs">Static Private Attributes</a> &#124;
<a href="classMessageHandler-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">MessageHandler Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>The <a class="el" href="classMessageHandler.html" title="The MessageHandler class is designed using a Singleton design pattern so that one object can be used ...">MessageHandler</a> class is designed using a Singleton design pattern so that one object can be used throughout the code for communication with the embedded system or simulated embedded system, regardless of our location within the code. The communication is handled with separate threads for sending messages to the embedded system, receiving messages from the embedded system, and simulating the embedded system. Using the object, a user can simply call a function to send a message and the receive the appropriate data as a result.  
 <a href="classMessageHandler.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="MessageHandler_8h_source.html">MessageHandler.h</a>&gt;</code></p>
<div class="dynheader">
Collaboration diagram for MessageHandler:</div>
<div class="dyncontent">
<div class="center"><img src="classMessageHandler__coll__graph.png" border="0" usemap="#MessageHandler_coll__map" alt="Collaboration graph"/></div>
<map name="MessageHandler_coll__map" id="MessageHandler_coll__map">
<area shape="rect" title="The MessageHandler class is designed using a Singleton design pattern so that one object can be used ..." alt="" coords="5,109,136,136"/>
<area shape="rect" href="classMessagePacket.html" title="This class is responsible for organizing message packets to be sent to&#45;and&#45;from an embedded system re..." alt="" coords="9,5,132,32"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a593ec9368dc622e07514e457b5b3ec6a"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMessageHandler.html#a593ec9368dc622e07514e457b5b3ec6a">getMessageIDCount</a> ()</td></tr>
<tr class="memdesc:a593ec9368dc622e07514e457b5b3ec6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the Message I D Count object.  <a href="classMessageHandler.html#a593ec9368dc622e07514e457b5b3ec6a">More...</a><br /></td></tr>
<tr class="separator:a593ec9368dc622e07514e457b5b3ec6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96d6489054bfcb67b323ce8c7a9f52a6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMessagePacket.html">MessagePacket</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMessageHandler.html#a96d6489054bfcb67b323ce8c7a9f52a6">getWaitingMessage</a> ()</td></tr>
<tr class="memdesc:a96d6489054bfcb67b323ce8c7a9f52a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the Waiting Message object.  <a href="classMessageHandler.html#a96d6489054bfcb67b323ce8c7a9f52a6">More...</a><br /></td></tr>
<tr class="separator:a96d6489054bfcb67b323ce8c7a9f52a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50e37c55f19ca7af3f2877da094d2066"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMessagePacket.html">MessagePacket</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMessageHandler.html#a50e37c55f19ca7af3f2877da094d2066">getReceivedMessage</a> ()</td></tr>
<tr class="memdesc:a50e37c55f19ca7af3f2877da094d2066"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the Received Message object.  <a href="classMessageHandler.html#a50e37c55f19ca7af3f2877da094d2066">More...</a><br /></td></tr>
<tr class="separator:a50e37c55f19ca7af3f2877da094d2066"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77f93e53f5d51d56fe8272390a88d5b8"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMessageHandler.html#a77f93e53f5d51d56fe8272390a88d5b8">sendMessage</a> (std::string message, std::string arguements=&quot;&quot;)</td></tr>
<tr class="memdesc:a77f93e53f5d51d56fe8272390a88d5b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is the main function to be used throught the code structure for the project and operates by taking a desired message to send and any associated arguements if necessary. The values are put together into a <a class="el" href="classMessagePacket.html" title="This class is responsible for organizing message packets to be sent to-and-from an embedded system re...">MessagePacket</a>, which is placed on the outgoingQueue for sending. Sending and receiving are handled by threads, and the function is then notified of a response received through incomingMutex. The received message is taken off of the incomingQueue and processed for results and data returned through a vector.  <a href="classMessageHandler.html#a77f93e53f5d51d56fe8272390a88d5b8">More...</a><br /></td></tr>
<tr class="separator:a77f93e53f5d51d56fe8272390a88d5b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfeea9909b02a3f53a30a2fa5d718842"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMessageHandler.html#abfeea9909b02a3f53a30a2fa5d718842">unsolicitedQueueGet</a> ()</td></tr>
<tr class="memdesc:abfeea9909b02a3f53a30a2fa5d718842"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is responsible for checking if the unsolicitedQueue of the <a class="el" href="classMessageHandler.html" title="The MessageHandler class is designed using a Singleton design pattern so that one object can be used ...">MessageHandler</a> singleton has any messages. Ideally, the unsolicited queue would be handled through the incomingQueue, and be processed in a separate thread that would use interrupts or signals to identify important events (such as when a goal is scored). However, this function operates in a manner To simulate the embedded system comunication, and as a result, because there is only a single MAIN thread for sending and receiving messages, the function can be polled to identify whether a message was successfully received in the unsolicited queue!  <a href="classMessageHandler.html#abfeea9909b02a3f53a30a2fa5d718842">More...</a><br /></td></tr>
<tr class="separator:abfeea9909b02a3f53a30a2fa5d718842"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a3effd99256956d3212cfaad1b15d39db"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classMessageHandler.html">MessageHandler</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMessageHandler.html#a3effd99256956d3212cfaad1b15d39db">instance</a> ()</td></tr>
<tr class="memdesc:a3effd99256956d3212cfaad1b15d39db"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is responsible for creating the single <a class="el" href="classMessageHandler.html" title="The MessageHandler class is designed using a Singleton design pattern so that one object can be used ...">MessageHandler</a> object for the Singleton design pattern.  <a href="classMessageHandler.html#a3effd99256956d3212cfaad1b15d39db">More...</a><br /></td></tr>
<tr class="separator:a3effd99256956d3212cfaad1b15d39db"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a4f6165a34fa3a4de7021e7e5cd7fd4f6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMessageHandler.html#a4f6165a34fa3a4de7021e7e5cd7fd4f6">MessageHandler</a> ()</td></tr>
<tr class="memdesc:a4f6165a34fa3a4de7021e7e5cd7fd4f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a new Message Handler:: Message Handler object The constructor is responsible for intializing all attributes, but also starts the threads used with the Message Handler because a Singleton pattern is used and only allows for single thread creation with a single object. Protected to prevent instantiation.  <a href="classMessageHandler.html#a4f6165a34fa3a4de7021e7e5cd7fd4f6">More...</a><br /></td></tr>
<tr class="separator:a4f6165a34fa3a4de7021e7e5cd7fd4f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae80c8fc5c8f0ac0eed6d4420d327e6e5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMessageHandler.html#ae80c8fc5c8f0ac0eed6d4420d327e6e5">~MessageHandler</a> ()</td></tr>
<tr class="memdesc:ae80c8fc5c8f0ac0eed6d4420d327e6e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy the Message Handler object.  <a href="classMessageHandler.html#ae80c8fc5c8f0ac0eed6d4420d327e6e5">More...</a><br /></td></tr>
<tr class="separator:ae80c8fc5c8f0ac0eed6d4420d327e6e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a42f7714173e0578bfe2c389fd339856b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMessageHandler.html#a42f7714173e0578bfe2c389fd339856b">MessageHandler</a> (const <a class="el" href="classMessageHandler.html">MessageHandler</a> &amp;other)</td></tr>
<tr class="memdesc:a42f7714173e0578bfe2c389fd339856b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make copy constructor private in overloads to prevent accidental creation of another singleton.  <a href="classMessageHandler.html#a42f7714173e0578bfe2c389fd339856b">More...</a><br /></td></tr>
<tr class="separator:a42f7714173e0578bfe2c389fd339856b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1961202bc417ec8fcef8f72932ff4558"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMessageHandler.html">MessageHandler</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMessageHandler.html#a1961202bc417ec8fcef8f72932ff4558">operator=</a> (const <a class="el" href="classMessageHandler.html">MessageHandler</a> &amp;other)</td></tr>
<tr class="memdesc:a1961202bc417ec8fcef8f72932ff4558"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make assignment operator private in overloads to prevent accidental creation of another singleton.  <a href="classMessageHandler.html#a1961202bc417ec8fcef8f72932ff4558">More...</a><br /></td></tr>
<tr class="separator:a1961202bc417ec8fcef8f72932ff4558"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3e8f75b7a1a4f06a6bbfad9e648d0b8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMessageHandler.html#ab3e8f75b7a1a4f06a6bbfad9e648d0b8">sendQueueMessagesThread</a> ()</td></tr>
<tr class="memdesc:ab3e8f75b7a1a4f06a6bbfad9e648d0b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">The sendQueueMessagesThread is responsible for operating as a thread that sends messages to the embedded system. When a message is available to send, it receives a notification through the outgoingMutex and then takes the next message to send from the outgoingQueue. For simulation purposes, the message is sent through a Pipe as the Tx line.  <a href="classMessageHandler.html#ab3e8f75b7a1a4f06a6bbfad9e648d0b8">More...</a><br /></td></tr>
<tr class="separator:ab3e8f75b7a1a4f06a6bbfad9e648d0b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab55a66de430f9409f41224d00e314306"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMessageHandler.html#ab55a66de430f9409f41224d00e314306">receiveQueueMessagesThread</a> ()</td></tr>
<tr class="memdesc:ab55a66de430f9409f41224d00e314306"><td class="mdescLeft">&#160;</td><td class="mdescRight">The receiveQueueMessagesThread is responsible for operating as a thread that receives messages from the embedded system. When a message is receives, it receives a notification through the pipe, simulationPipeReceive, and then takes the recieved message, and puts it on the incomingQueue. The thread also notifies that it has put a received message on the queue using incomingMutex. It is noted that the thread is intended to behave as the Rx line.  <a href="classMessageHandler.html#ab55a66de430f9409f41224d00e314306">More...</a><br /></td></tr>
<tr class="separator:ab55a66de430f9409f41224d00e314306"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff3b2c1cb924899403daef56b7ae67e3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMessageHandler.html#aff3b2c1cb924899403daef56b7ae67e3">embeddedSystemSimulation</a> ()</td></tr>
<tr class="memdesc:aff3b2c1cb924899403daef56b7ae67e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">The embeddedSystemSimulation is responsible for operating as a thread that simulates the embedded system. As a result, it is responsible for receiving and parsing messages, acting accordingly to the messages, and then sending a valid response.  <a href="classMessageHandler.html#aff3b2c1cb924899403daef56b7ae67e3">More...</a><br /></td></tr>
<tr class="separator:aff3b2c1cb924899403daef56b7ae67e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a4066c441ca1015c5c1aa1766ea2e6b83"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMessagePacket.html">MessagePacket</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMessageHandler.html#a4066c441ca1015c5c1aa1766ea2e6b83">waitingMessage</a></td></tr>
<tr class="memdesc:a4066c441ca1015c5c1aa1766ea2e6b83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used to identify the message that was sent and is waiting for a response.  <a href="classMessageHandler.html#a4066c441ca1015c5c1aa1766ea2e6b83">More...</a><br /></td></tr>
<tr class="separator:a4066c441ca1015c5c1aa1766ea2e6b83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a847fcfe5cc161ae7af0d42f9c28f66f2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMessagePacket.html">MessagePacket</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMessageHandler.html#a847fcfe5cc161ae7af0d42f9c28f66f2">receivedMessage</a></td></tr>
<tr class="memdesc:a847fcfe5cc161ae7af0d42f9c28f66f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used to identify the message that was received and can be processed.  <a href="classMessageHandler.html#a847fcfe5cc161ae7af0d42f9c28f66f2">More...</a><br /></td></tr>
<tr class="separator:a847fcfe5cc161ae7af0d42f9c28f66f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42e007a4f8e489b5afab933cf9799247"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMessageHandler.html#a42e007a4f8e489b5afab933cf9799247">messageIDCount</a></td></tr>
<tr class="memdesc:a42e007a4f8e489b5afab933cf9799247"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used to identify the ID of the message to be sent.  <a href="classMessageHandler.html#a42e007a4f8e489b5afab933cf9799247">More...</a><br /></td></tr>
<tr class="separator:a42e007a4f8e489b5afab933cf9799247"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa55aea7fd4b7a37e4229996b61ec07d3"><td class="memItemLeft" align="right" valign="top">std::queue&lt; <a class="el" href="classMessagePacket.html">MessagePacket</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMessageHandler.html#aa55aea7fd4b7a37e4229996b61ec07d3">incomingQueue</a></td></tr>
<tr class="memdesc:aa55aea7fd4b7a37e4229996b61ec07d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Queue used if multiple messages are being received simultaneously.  <a href="classMessageHandler.html#aa55aea7fd4b7a37e4229996b61ec07d3">More...</a><br /></td></tr>
<tr class="separator:aa55aea7fd4b7a37e4229996b61ec07d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af55652f764c084cb4daed7869e424c1b"><td class="memItemLeft" align="right" valign="top">std::queue&lt; <a class="el" href="classMessagePacket.html">MessagePacket</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMessageHandler.html#af55652f764c084cb4daed7869e424c1b">unsolicitedQueue</a></td></tr>
<tr class="memdesc:af55652f764c084cb4daed7869e424c1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Queue used for handling multiple unsolicited messages simultaneously.  <a href="classMessageHandler.html#af55652f764c084cb4daed7869e424c1b">More...</a><br /></td></tr>
<tr class="separator:af55652f764c084cb4daed7869e424c1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a188c943e1e4901868147ed8a8f0bcb54"><td class="memItemLeft" align="right" valign="top">std::queue&lt; <a class="el" href="classMessagePacket.html">MessagePacket</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMessageHandler.html#a188c943e1e4901868147ed8a8f0bcb54">outgoingQueue</a></td></tr>
<tr class="memdesc:a188c943e1e4901868147ed8a8f0bcb54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Queue used if multiple messages are being sent simultaneously.  <a href="classMessageHandler.html#a188c943e1e4901868147ed8a8f0bcb54">More...</a><br /></td></tr>
<tr class="separator:a188c943e1e4901868147ed8a8f0bcb54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95511330ce6c2ebd1100a253d125bdb8"><td class="memItemLeft" align="right" valign="top">std::thread&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMessageHandler.html#a95511330ce6c2ebd1100a253d125bdb8">outgoingThread</a></td></tr>
<tr class="memdesc:a95511330ce6c2ebd1100a253d125bdb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Thread used for sending messages to the embedded system.  <a href="classMessageHandler.html#a95511330ce6c2ebd1100a253d125bdb8">More...</a><br /></td></tr>
<tr class="separator:a95511330ce6c2ebd1100a253d125bdb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56dc9c332b2d5ee2cfd5549ea3c94e17"><td class="memItemLeft" align="right" valign="top">std::thread&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMessageHandler.html#a56dc9c332b2d5ee2cfd5549ea3c94e17">incomingThread</a></td></tr>
<tr class="memdesc:a56dc9c332b2d5ee2cfd5549ea3c94e17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Thread used for receiving messages from the embedded system.  <a href="classMessageHandler.html#a56dc9c332b2d5ee2cfd5549ea3c94e17">More...</a><br /></td></tr>
<tr class="separator:a56dc9c332b2d5ee2cfd5549ea3c94e17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5fd2852fd8128b16a408361c775aa3a"><td class="memItemLeft" align="right" valign="top">std::thread&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMessageHandler.html#ad5fd2852fd8128b16a408361c775aa3a">embeddedSystemSimThread</a></td></tr>
<tr class="memdesc:ad5fd2852fd8128b16a408361c775aa3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Thread used for simulating the embedded system.  <a href="classMessageHandler.html#ad5fd2852fd8128b16a408361c775aa3a">More...</a><br /></td></tr>
<tr class="separator:ad5fd2852fd8128b16a408361c775aa3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac42fe99c568323aafe9fb77305d1f2e0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMessageHandler.html#ac42fe99c568323aafe9fb77305d1f2e0">simulationPipeSend</a> [2]</td></tr>
<tr class="memdesc:ac42fe99c568323aafe9fb77305d1f2e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pipe used to simulate the USART Tx line.  <a href="classMessageHandler.html#ac42fe99c568323aafe9fb77305d1f2e0">More...</a><br /></td></tr>
<tr class="separator:ac42fe99c568323aafe9fb77305d1f2e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd1f8f66fa2e0187d3d86d22617c631a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMessageHandler.html#acd1f8f66fa2e0187d3d86d22617c631a">simulationPipeReceive</a> [2]</td></tr>
<tr class="memdesc:acd1f8f66fa2e0187d3d86d22617c631a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pipe used to simulate the USART Rx line.  <a href="classMessageHandler.html#acd1f8f66fa2e0187d3d86d22617c631a">More...</a><br /></td></tr>
<tr class="separator:acd1f8f66fa2e0187d3d86d22617c631a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bc97985def64285f01d1bde540754ec"><td class="memItemLeft" align="right" valign="top">std::mutex&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMessageHandler.html#a5bc97985def64285f01d1bde540754ec">outgoingMutex</a></td></tr>
<tr class="memdesc:a5bc97985def64285f01d1bde540754ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mutex used as a flag to identify when a message is ready to send.  <a href="classMessageHandler.html#a5bc97985def64285f01d1bde540754ec">More...</a><br /></td></tr>
<tr class="separator:a5bc97985def64285f01d1bde540754ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26d64af932480eb262af5f9d46455a35"><td class="memItemLeft" align="right" valign="top">std::mutex&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMessageHandler.html#a26d64af932480eb262af5f9d46455a35">incomingMutex</a></td></tr>
<tr class="memdesc:a26d64af932480eb262af5f9d46455a35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mutex used as a flag to identify when a message has been received.  <a href="classMessageHandler.html#a26d64af932480eb262af5f9d46455a35">More...</a><br /></td></tr>
<tr class="separator:a26d64af932480eb262af5f9d46455a35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b269864acb62b22a9cee1d1b1ee26ad"><td class="memItemLeft" align="right" valign="top">std::mutex&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMessageHandler.html#a0b269864acb62b22a9cee1d1b1ee26ad">unsolicitedMutex</a></td></tr>
<tr class="memdesc:a0b269864acb62b22a9cee1d1b1ee26ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mutex used to protect access to the unsolicited queue.  <a href="classMessageHandler.html#a0b269864acb62b22a9cee1d1b1ee26ad">More...</a><br /></td></tr>
<tr class="separator:a0b269864acb62b22a9cee1d1b1ee26ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-static-attribs"></a>
Static Private Attributes</h2></td></tr>
<tr class="memitem:a5354ae6910e75f6b9dcfab996d0d986b"><td class="memItemLeft" align="right" valign="top">static std::mutex&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMessageHandler.html#a5354ae6910e75f6b9dcfab996d0d986b">instantiateMutex</a></td></tr>
<tr class="memdesc:a5354ae6910e75f6b9dcfab996d0d986b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mutex used for thread-safe Singleton creation.  <a href="classMessageHandler.html#a5354ae6910e75f6b9dcfab996d0d986b">More...</a><br /></td></tr>
<tr class="separator:a5354ae6910e75f6b9dcfab996d0d986b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b118df89e1c0ddaee5098f881bde346"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classMessageHandler.html">MessageHandler</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMessageHandler.html#a3b118df89e1c0ddaee5098f881bde346">_instance</a> = NULL</td></tr>
<tr class="memdesc:a3b118df89e1c0ddaee5098f881bde346"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer used to contain a reference to the Singleton.  <a href="classMessageHandler.html#a3b118df89e1c0ddaee5098f881bde346">More...</a><br /></td></tr>
<tr class="separator:a3b118df89e1c0ddaee5098f881bde346"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The <a class="el" href="classMessageHandler.html" title="The MessageHandler class is designed using a Singleton design pattern so that one object can be used ...">MessageHandler</a> class is designed using a Singleton design pattern so that one object can be used throughout the code for communication with the embedded system or simulated embedded system, regardless of our location within the code. The communication is handled with separate threads for sending messages to the embedded system, receiving messages from the embedded system, and simulating the embedded system. Using the object, a user can simply call a function to send a message and the receive the appropriate data as a result. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a42f7714173e0578bfe2c389fd339856b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42f7714173e0578bfe2c389fd339856b">&#9670;&nbsp;</a></span>MessageHandler() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MessageHandler::MessageHandler </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMessageHandler.html">MessageHandler</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Make copy constructor private in overloads to prevent accidental creation of another singleton. </p>

</div>
</div>
<a id="a4f6165a34fa3a4de7021e7e5cd7fd4f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f6165a34fa3a4de7021e7e5cd7fd4f6">&#9670;&nbsp;</a></span>MessageHandler() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MessageHandler::MessageHandler </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a new Message Handler:: Message Handler object The constructor is responsible for intializing all attributes, but also starts the threads used with the Message Handler because a Singleton pattern is used and only allows for single thread creation with a single object. Protected to prevent instantiation. </p>

</div>
</div>
<a id="ae80c8fc5c8f0ac0eed6d4420d327e6e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae80c8fc5c8f0ac0eed6d4420d327e6e5">&#9670;&nbsp;</a></span>~MessageHandler()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MessageHandler::~MessageHandler </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroy the Message Handler object. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="aff3b2c1cb924899403daef56b7ae67e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff3b2c1cb924899403daef56b7ae67e3">&#9670;&nbsp;</a></span>embeddedSystemSimulation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MessageHandler::embeddedSystemSimulation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The embeddedSystemSimulation is responsible for operating as a thread that simulates the embedded system. As a result, it is responsible for receiving and parsing messages, acting accordingly to the messages, and then sending a valid response. </p>

</div>
</div>
<a id="a593ec9368dc622e07514e457b5b3ec6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a593ec9368dc622e07514e457b5b3ec6a">&#9670;&nbsp;</a></span>getMessageIDCount()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int MessageHandler::getMessageIDCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the Message I D Count object. </p>
<dl class="section return"><dt>Returns</dt><dd>unsigned int =&gt; Returns an unsigned int containing the <a class="el" href="classMessageHandler.html#a42e007a4f8e489b5afab933cf9799247">messageIDCount</a> attribute </dd></dl>

</div>
</div>
<a id="a50e37c55f19ca7af3f2877da094d2066"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50e37c55f19ca7af3f2877da094d2066">&#9670;&nbsp;</a></span>getReceivedMessage()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMessagePacket.html">MessagePacket</a> MessageHandler::getReceivedMessage </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the Received Message object. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classMessagePacket.html" title="This class is responsible for organizing message packets to be sent to-and-from an embedded system re...">MessagePacket</a> =&gt; Returns a <a class="el" href="classMessagePacket.html" title="This class is responsible for organizing message packets to be sent to-and-from an embedded system re...">MessagePacket</a> containing the <a class="el" href="classMessageHandler.html#a847fcfe5cc161ae7af0d42f9c28f66f2">receivedMessage</a> attribute </dd></dl>

</div>
</div>
<a id="a96d6489054bfcb67b323ce8c7a9f52a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96d6489054bfcb67b323ce8c7a9f52a6">&#9670;&nbsp;</a></span>getWaitingMessage()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMessagePacket.html">MessagePacket</a> MessageHandler::getWaitingMessage </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the Waiting Message object. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classMessagePacket.html" title="This class is responsible for organizing message packets to be sent to-and-from an embedded system re...">MessagePacket</a> =&gt; Returns a <a class="el" href="classMessagePacket.html" title="This class is responsible for organizing message packets to be sent to-and-from an embedded system re...">MessagePacket</a> containing the <a class="el" href="classMessageHandler.html#a4066c441ca1015c5c1aa1766ea2e6b83">waitingMessage</a> attribute </dd></dl>

</div>
</div>
<a id="a3effd99256956d3212cfaad1b15d39db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3effd99256956d3212cfaad1b15d39db">&#9670;&nbsp;</a></span>instance()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMessageHandler.html">MessageHandler</a> &amp; MessageHandler::instance </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function is responsible for creating the single <a class="el" href="classMessageHandler.html" title="The MessageHandler class is designed using a Singleton design pattern so that one object can be used ...">MessageHandler</a> object for the Singleton design pattern. </p>
<p>NOTE: The Double-Checked Locking Pattern (DCLP) is used when initializing the _instance variable to ensure that we have efficient, thread-safe implementation of the Singleton initialization. Although there are some issues associated with DCLP, we assume proper functionality here</p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classMessageHandler.html" title="The MessageHandler class is designed using a Singleton design pattern so that one object can be used ...">MessageHandler</a>&amp; </dd></dl>

</div>
</div>
<a id="a1961202bc417ec8fcef8f72932ff4558"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1961202bc417ec8fcef8f72932ff4558">&#9670;&nbsp;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMessageHandler.html">MessageHandler</a>&amp; MessageHandler::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMessageHandler.html">MessageHandler</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Make assignment operator private in overloads to prevent accidental creation of another singleton. </p>

</div>
</div>
<a id="ab55a66de430f9409f41224d00e314306"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab55a66de430f9409f41224d00e314306">&#9670;&nbsp;</a></span>receiveQueueMessagesThread()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MessageHandler::receiveQueueMessagesThread </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The receiveQueueMessagesThread is responsible for operating as a thread that receives messages from the embedded system. When a message is receives, it receives a notification through the pipe, simulationPipeReceive, and then takes the recieved message, and puts it on the incomingQueue. The thread also notifies that it has put a received message on the queue using incomingMutex. It is noted that the thread is intended to behave as the Rx line. </p>

</div>
</div>
<a id="a77f93e53f5d51d56fe8272390a88d5b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77f93e53f5d51d56fe8272390a88d5b8">&#9670;&nbsp;</a></span>sendMessage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; int &gt; MessageHandler::sendMessage </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>message</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>arguements</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is the main function to be used throught the code structure for the project and operates by taking a desired message to send and any associated arguements if necessary. The values are put together into a <a class="el" href="classMessagePacket.html" title="This class is responsible for organizing message packets to be sent to-and-from an embedded system re...">MessagePacket</a>, which is placed on the outgoingQueue for sending. Sending and receiving are handled by threads, and the function is then notified of a response received through incomingMutex. The received message is taken off of the incomingQueue and processed for results and data returned through a vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">message</td><td>-&gt; Message to send to the embedded system according to <a class="el" href="MessageLibrary_8h.html">MessageLibrary.h</a> </td></tr>
    <tr><td class="paramname">arguements</td><td>-&gt; Arguments to send along with the message </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::vector&lt;int&gt; -&gt; Pertinent data associated with the response to the sent message. IF there was an error, the FIRST element of the vector takes a negative value IF the transaction was successful, the FIRST element is the ID of the message, and the following elements correspond to any arguements that were returned as part of the message </dd></dl>

</div>
</div>
<a id="ab3e8f75b7a1a4f06a6bbfad9e648d0b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3e8f75b7a1a4f06a6bbfad9e648d0b8">&#9670;&nbsp;</a></span>sendQueueMessagesThread()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MessageHandler::sendQueueMessagesThread </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The sendQueueMessagesThread is responsible for operating as a thread that sends messages to the embedded system. When a message is available to send, it receives a notification through the outgoingMutex and then takes the next message to send from the outgoingQueue. For simulation purposes, the message is sent through a Pipe as the Tx line. </p>

</div>
</div>
<a id="abfeea9909b02a3f53a30a2fa5d718842"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfeea9909b02a3f53a30a2fa5d718842">&#9670;&nbsp;</a></span>unsolicitedQueueGet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; int &gt; MessageHandler::unsolicitedQueueGet </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is responsible for checking if the unsolicitedQueue of the <a class="el" href="classMessageHandler.html" title="The MessageHandler class is designed using a Singleton design pattern so that one object can be used ...">MessageHandler</a> singleton has any messages. Ideally, the unsolicited queue would be handled through the incomingQueue, and be processed in a separate thread that would use interrupts or signals to identify important events (such as when a goal is scored). However, this function operates in a manner To simulate the embedded system comunication, and as a result, because there is only a single MAIN thread for sending and receiving messages, the function can be polled to identify whether a message was successfully received in the unsolicited queue! </p>
<dl class="section return"><dt>Returns</dt><dd>std::vector&lt;int&gt; If the unsolicitedQueue is empty, the firs value in the vector is returned as a negative (-1), which is the ONLY value in the vector If the unsolicitedQueue had a message, the message is removed, and the first value of the vector is returned as the ID of the message received, while the remaining values in the vector are returned as values associated with the message on the queue (Because there is ONLY 1 message type that can be sent unsolicited, it is always the goal side and then the goal speed in the vector)</dd></dl>
<p>Ex. vect&lt;int&gt;[0] = 100 (messageID), vect&lt;int&gt;[0] = 1 (goalSide), vect&lt;int&gt;[0] = 100 (goalSpeed) </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a3b118df89e1c0ddaee5098f881bde346"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b118df89e1c0ddaee5098f881bde346">&#9670;&nbsp;</a></span>_instance</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMessageHandler.html">MessageHandler</a> * MessageHandler::_instance = NULL</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pointer used to contain a reference to the Singleton. </p>

</div>
</div>
<a id="ad5fd2852fd8128b16a408361c775aa3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5fd2852fd8128b16a408361c775aa3a">&#9670;&nbsp;</a></span>embeddedSystemSimThread</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::thread MessageHandler::embeddedSystemSimThread</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Thread used for simulating the embedded system. </p>

</div>
</div>
<a id="a26d64af932480eb262af5f9d46455a35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26d64af932480eb262af5f9d46455a35">&#9670;&nbsp;</a></span>incomingMutex</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::mutex MessageHandler::incomingMutex</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Mutex used as a flag to identify when a message has been received. </p>

</div>
</div>
<a id="aa55aea7fd4b7a37e4229996b61ec07d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa55aea7fd4b7a37e4229996b61ec07d3">&#9670;&nbsp;</a></span>incomingQueue</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::queue&lt;<a class="el" href="classMessagePacket.html">MessagePacket</a>&gt; MessageHandler::incomingQueue</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Queue used if multiple messages are being received simultaneously. </p>

</div>
</div>
<a id="a56dc9c332b2d5ee2cfd5549ea3c94e17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56dc9c332b2d5ee2cfd5549ea3c94e17">&#9670;&nbsp;</a></span>incomingThread</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::thread MessageHandler::incomingThread</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Thread used for receiving messages from the embedded system. </p>

</div>
</div>
<a id="a5354ae6910e75f6b9dcfab996d0d986b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5354ae6910e75f6b9dcfab996d0d986b">&#9670;&nbsp;</a></span>instantiateMutex</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::mutex MessageHandler::instantiateMutex</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Mutex used for thread-safe Singleton creation. </p>

</div>
</div>
<a id="a42e007a4f8e489b5afab933cf9799247"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42e007a4f8e489b5afab933cf9799247">&#9670;&nbsp;</a></span>messageIDCount</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int MessageHandler::messageIDCount</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Used to identify the ID of the message to be sent. </p>

</div>
</div>
<a id="a5bc97985def64285f01d1bde540754ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bc97985def64285f01d1bde540754ec">&#9670;&nbsp;</a></span>outgoingMutex</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::mutex MessageHandler::outgoingMutex</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Mutex used as a flag to identify when a message is ready to send. </p>

</div>
</div>
<a id="a188c943e1e4901868147ed8a8f0bcb54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a188c943e1e4901868147ed8a8f0bcb54">&#9670;&nbsp;</a></span>outgoingQueue</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::queue&lt;<a class="el" href="classMessagePacket.html">MessagePacket</a>&gt; MessageHandler::outgoingQueue</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Queue used if multiple messages are being sent simultaneously. </p>

</div>
</div>
<a id="a95511330ce6c2ebd1100a253d125bdb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95511330ce6c2ebd1100a253d125bdb8">&#9670;&nbsp;</a></span>outgoingThread</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::thread MessageHandler::outgoingThread</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Thread used for sending messages to the embedded system. </p>

</div>
</div>
<a id="a847fcfe5cc161ae7af0d42f9c28f66f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a847fcfe5cc161ae7af0d42f9c28f66f2">&#9670;&nbsp;</a></span>receivedMessage</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMessagePacket.html">MessagePacket</a> MessageHandler::receivedMessage</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Used to identify the message that was received and can be processed. </p>

</div>
</div>
<a id="acd1f8f66fa2e0187d3d86d22617c631a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd1f8f66fa2e0187d3d86d22617c631a">&#9670;&nbsp;</a></span>simulationPipeReceive</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int MessageHandler::simulationPipeReceive[2]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pipe used to simulate the USART Rx line. </p>

</div>
</div>
<a id="ac42fe99c568323aafe9fb77305d1f2e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac42fe99c568323aafe9fb77305d1f2e0">&#9670;&nbsp;</a></span>simulationPipeSend</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int MessageHandler::simulationPipeSend[2]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pipe used to simulate the USART Tx line. </p>

</div>
</div>
<a id="a0b269864acb62b22a9cee1d1b1ee26ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b269864acb62b22a9cee1d1b1ee26ad">&#9670;&nbsp;</a></span>unsolicitedMutex</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::mutex MessageHandler::unsolicitedMutex</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Mutex used to protect access to the unsolicited queue. </p>

</div>
</div>
<a id="af55652f764c084cb4daed7869e424c1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af55652f764c084cb4daed7869e424c1b">&#9670;&nbsp;</a></span>unsolicitedQueue</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::queue&lt;<a class="el" href="classMessagePacket.html">MessagePacket</a>&gt; MessageHandler::unsolicitedQueue</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Queue used for handling multiple unsolicited messages simultaneously. </p>

</div>
</div>
<a id="a4066c441ca1015c5c1aa1766ea2e6b83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4066c441ca1015c5c1aa1766ea2e6b83">&#9670;&nbsp;</a></span>waitingMessage</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMessagePacket.html">MessagePacket</a> MessageHandler::waitingMessage</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Used to identify the message that was sent and is waiting for a response. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="MessageHandler_8h_source.html">MessageHandler.h</a></li>
<li><a class="el" href="MessageHandler_8cpp.html">MessageHandler.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
